{% extends 'map/base.html' %}
{% block content %}
        <div class="card-panel col s12 m12">
            {% if gpxObj %}<div class="card-title"><h3>{{ gpxObj.name }}</h3> <p>uploaded {{ gpxObj.uploadDate|timesince }} ago on {{ gpxObj.uploadDate|date:"SHORT_DATE_FORMAT" }}</p></div>{% endif %}
            <div id="map" style="height: 650px;"></div>
        <a href="#" onclick="dodownload('{{ gpxObj.name }}.json', JSON.stringify(routeJSON, null, 2))">Download as Route.</a>
        </div>
    <script>

            var _getClosestPointIndex = function(lPoint, arrayLPoints) {
                var distanceArray = [];
                for ( var i = 0; i < arrayLPoints.length; i++ ) {
                    distanceArray.push( lPoint.distanceTo(arrayLPoints[i]) );
                }
                return distanceArray.indexOf(  Math.min.apply(null, distanceArray) );
            };

          var map = L.map('map').setView([52.1428215, 7.3225525], 15);
              L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
              {
                attribution: 'Map data &copy; <a href="http://www.osm.org">OpenStreetMap</a>'
              }
            ).addTo(map);
          {% if specific %}

              var gpx = "{{ gpxObj.file.url }}"; // URL to your GPX file or the GPX itself

    var xmlDoc;

    if(typeof window.DOMParser != "undefined") {
        xmlhttp=new XMLHttpRequest();
        xmlhttp.open("GET",gpx,false);
        if (xmlhttp.overrideMimeType){
            xmlhttp.overrideMimeType('text/xml');
        }
        xmlhttp.send();
        xmlDoc=xmlhttp.responseXML;
    }
    else{
        xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
        xmlDoc.async="false";
        xmlDoc.load(xmlFile);
    }

    var LatLonArray=[]
    var SpeedArray =[]
    var AccuracyArray = []

    var tracksegments = xmlDoc.getElementsByTagName( 'trkseg' );
    for ( var i = 0, len_i = tracksegments.length; i < len_i; i++ ) {
        currentTracksegment = tracksegments[i];
        for(var j = 0, len_j = currentTracksegment.childNodes.length; j < len_j; j++)
        {
            currentTrackPt = currentTracksegment.childNodes[j];
             if (currentTrackPt.nodeType === 1)
            {
              var accuracy = currentTrackPt.getElementsByTagName('accuracy')
              for( var k = 0, len_k = accuracy.length; k < len_k; k++ )
              {
                if(accuracy[k].nodeType === 1){

                      AccuracyArray.push(accuracy[k].firstChild.nodeValue)
                }
              }

              var speed = currentTrackPt.getElementsByTagName('speed')
              for( var k = 0, len_k = speed.length; k < len_k; k++ )
              {
                if(speed[k].nodeType === 1){

                      SpeedArray.push(speed[k].firstChild.nodeValue)
                }
              }

              LatLonArray.push(L.latLng({
                lat: currentTrackPt.getAttribute('lat'),
                lon: currentTrackPt.getAttribute('lon')
              }));

            }
        }

        hotlineData = []
        for( var index = 0, len_index = LatLonArray.length; index < len_index; index++)
        {
          newDataPoint = [LatLonArray[index].lat, LatLonArray[index].lng, AccuracyArray[index]]
          hotlineData.push(newDataPoint)
        }

        var hotlineOptions = {
      			min: Math.min.apply(null, AccuracyArray),
      			max: Math.max.apply(null, AccuracyArray),
      			palette: {
      				0.0: '#008800',
      				0.5: '#ffff00',
      				1.0: '#ff0000'
      			},
      			weight: 3,
      			outlineColor: '#000000',
      			outlineWidth: 1
		      }
        var mypolyline =  L.hotline(hotlineData, hotlineOptions).
          on('mouseover', function(e){
            var index = _getClosestPointIndex(e.latlng, LatLonArray);
             var popup = L.popup()
                 .setLatLng(LatLonArray[index])
                 .setContent('<p>Speed: '+ SpeedArray[index] +'m/s<br />Accuracy: '+ AccuracyArray[index] +'m.</p>')
                 .openOn(self.map);
          }).addTo(map);
          //reformat data for hotline

          var routeInstructions = []
          var totalLength = 0

        var LonLatArray = []
        for(var step=0; step < LatLonArray.length; step++) {
            var point = [LatLonArray[step].lat, LatLonArray[step].lng]
            LonLatArray.push(point)
          }

        for(var step=0; step < LatLonArray.length; step++){
              if(step < LatLonArray.length-1){
                var Point1 = turf.point([LatLonArray[step].lat, LatLonArray[step].lng])
                var Point2 = turf.point([LatLonArray[step+1].lat, LatLonArray[step+1].lng])
                var subPathlength = turf.distance(Point1, Point2) * 1000 //calculate with turf
              }
              else{
                var subPathlength = 0;
              }


              var instructionCode = "0"
              var streetName = "Path"

              totalLength +=subPathlength
              var indexPosition = step
              var travelTime = 0
              var formatedLength = subPathlength +"m"
              var postTurnDir = "N"
              var postTurnAzimuth = 0
              var mode = 1
              var preTurnDir = "N"
              var preTurnAzimuth = 0
              routeInstruction = [instructionCode, streetName, subPathlength,
                                  indexPosition, travelTime, formatedLength,
                                  postTurnDir, postTurnAzimuth, mode,
                                  preTurnDir, preTurnAzimuth]


              routeInstructions.push(routeInstruction);
            }


            var encodedPolyline = polyline.encode(LonLatArray, 5)

        var routeJSON = {
              "status" : 0,
              "route_name" : ["route1"],
              "status_message" : "Found route between points",
              "route_geometry": encodedPolyline,
              "found_alternative":false,
              "route_summary": {
                "end_point": "Endpoint",
                "start_point": "Starpoint",
                "total_time": 209,
                "total_distance": totalLength
              },
              "route_instructions": routeInstructions
            }
        /*var mypolyline = L.polyline(LatLonArray,
          {
            color: 'blue',
            opacity: 0.5,
          }).
                          on('mouseover', function(e){
                            var index = _getClosestPointIndex(e.latlng, LatLonArray);
                             var popup = L.popup()
                                 .setLatLng(LatLonArray[index])
                                 .setContent('<p>Speed: '+ SpeedArray[index] +'m/s<br />Accuracy: '+ AccuracyArray[index] +'m.</p>')
                                 .openOn(self.map);
                          }).addTo(map);
                          */
        map.fitBounds(mypolyline.getBounds());
    }

          {% endif %}
</script>
{% endblock %}